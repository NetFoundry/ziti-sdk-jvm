/*
 * Copyright (c) 2018-2020 NetFoundry, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

buildscript {
    repositories {
        mavenCentral()
        google()
    }
    dependencies {
        classpath("com.android.tools.build:gradle:3.6.1")
        classpath("org.jfrog.buildinfo:build-info-extractor-gradle:4.14.1")
    }
}

plugins {
    id ("org.jetbrains.kotlin.jvm") version "1.3.61"
    id("io.wusa.semver-git-plugin") version "2.0.2"
    id("com.jfrog.artifactory") version "4.14.1"
}

repositories {
    mavenCentral()
    google()
}

ext {
    zitiBuildnum = System.getenv("BUILD_NUMBER") ?: "local"
}

group = "io.netfoundry.ziti"

semver {
    //nextVersion = "patch"
    snapshotSuffix = "pre"
    initialVersion = "0.1.0"
    branches {
        branch {
            regex = "master"
            incrementer = "NO_VERSION_INCREMENTER"
            formatter = { info -> "${info.version.major}.${info.version.minor}.${info.version.patch}-${zitiBuildnum}" }
        }
        branch {
            regex = ".+"
            incrementer = "NO_VERSION_INCREMENTER"
            formatter = { info ->
                val v = info.version
                """${info.branch.id}-${v.major}.${v.minor}.${v.patch}.${v.suffix?.count ?: "0"}.${v.suffix?.sha}""" }
        }
    }
}

ext {
    gitInfo = semver.info
    gitCommit = semver.info.shortCommit
    gitBranch = semver.info.branch.name
}

version = semver.info
println("version = ${version}")

subprojects {
    group = rootProject.group
    version = rootProject.version

    plugins.apply("com.jfrog.artifactory")

    tasks.withType(PublishToMavenRepository).all {
        onlyIf { !gitInfo.dirty }
    }
}

def sh (cmd, ...args) {
    def out = new ByteArrayOutputStream()
    this.exec {
        commandLine(cmd, *args)
        standardOutput = out
    }
    return out.toString()
}

tasks.register("tagIfNeeded") {

    if (gitBranch == "master" || true) {

        doLast {

            def zitiVer = file("version").readLines()[0].trim()

            def (zitiMajor, zitiMinor, zitiPatch) = zitiVer.split(/\./).collect { it.toInteger() }

            def tagMajor = semver.info.version.major
            def tagMinor = semver.info.version.minor
            def tagPatch = semver.info.version.patch
            def ahead = semver.info.version.suffix?.count

            if ( zitiMajor > tagMajor ||
                (zitiMajor == tagMajor && zitiMinor > tagMinor ) ||
                (zitiMinor == tagMajor && zitiMinor == tagMinor && zitiPatch > tagPatch) )
            {
                def new_tag = zitiVer
                println("advancing tag($new_tag) based on 'version' file")
                sh("git", "tag",  "-a",  new_tag, "-m", "CI tag ${new_tag}")
            } else {
                if (ahead == 0) {
                    println("already has tag = ${tagMajor}.${tagMinor}.${tagPatch}")
                    // new_tag = "${tagMajor}.${tagMinor}.${tagPatch}"
                }
                else {
                    println("bumping up new tag")
                    def new_tag = "${tagMajor}.${tagMinor}.${tagPatch + 1}"
                    println("setting new tag = $new_tag")
                    sh("git", "tag",  "-a",  new_tag, "-m", "CI tag ${new_tag}")
                }
            }

        }
    }
}
